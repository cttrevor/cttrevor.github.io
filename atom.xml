<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Trevor</title>
  <icon>https://www.gravatar.com/avatar/2a0b4946c9bb4b2d89e59c5aa8263ade</icon>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://cttrevor.github.io/"/>
  <updated>2018-01-27T08:25:16.000Z</updated>
  <id>https://cttrevor.github.io/</id>
  
  <author>
    <name>Trevor Cui</name>
    <email>ct1993@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二分查找</title>
    <link href="https://cttrevor.github.io/2018/01/27/binary-search/"/>
    <id>https://cttrevor.github.io/2018/01/27/binary-search/</id>
    <published>2018-01-26T16:00:00.000Z</published>
    <updated>2018-01-27T08:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找问题总的来说不复杂，主要麻烦的点在于边界问题。且不同的条件下二分的写法也都不一样。接下来就做一个总结。</p><h2 id="最基础的二分查找"><a href="#最基础的二分查找" class="headerlink" title="最基础的二分查找"></a>最基础的二分查找</h2><p>先看最基础，写起来也最简单的二分查找：只需要找到相等的位置就返回。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; k) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; k) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四个不同的边界问题"><a href="#四个不同的边界问题" class="headerlink" title="四个不同的边界问题"></a>四个不同的边界问题</h2><p>接下来的变种问题都对于单调不递减数组而言。</p><h3 id="查找最后一个等于或者小于-key-的元素"><a href="#查找最后一个等于或者小于-key-的元素" class="headerlink" title="查找最后一个等于或者小于 key 的元素"></a>查找最后一个等于或者小于 key 的元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastEqualSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; k) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找最后一个小于-key-的元素"><a href="#查找最后一个小于-key-的元素" class="headerlink" title="查找最后一个小于 key 的元素"></a>查找最后一个小于 key 的元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastSmaller</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= k) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找第一个等于或者大于-key-的元素"><a href="#查找第一个等于或者大于-key-的元素" class="headerlink" title="查找第一个等于或者大于 key 的元素"></a>查找第一个等于或者大于 key 的元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstEqualLarger</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= k) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查找第一个大于-key-的元素"><a href="#查找第一个大于-key-的元素" class="headerlink" title="查找第一个大于 key 的元素"></a>查找第一个大于 key 的元素</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">firstLarger</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; k) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>二分查找变种较多，不过它们的“套路”是一样的，以上代码就是其套路，如何快速写出二分查找的代码，只需按照以下步骤即可：</p><h3 id="首先判断出是返回-left，还是返回-right"><a href="#首先判断出是返回-left，还是返回-right" class="headerlink" title="首先判断出是返回 left，还是返回 right"></a>首先判断出是返回 left，还是返回 right</h3><p>因为我们知道最后跳出 <code>while (left &lt;= right)</code> 循环条件是 <code>right &lt; left</code>，且 <code>right = left - 1</code>。最后 <code>right</code> 和 <code>left</code> 一定是卡在“边界值”的左右两边，如果是比较值为 <code>key</code>，查找小于等于（或者是小于）<code>key</code> 的元素，则边界值就是等于 <code>key</code> 的所有元素的最左边那个，其实应该返回 <code>left</code>。</p><h3 id="判断出比较符号"><a href="#判断出比较符号" class="headerlink" title="判断出比较符号"></a>判断出比较符号</h3><p>也就是 <code>if (array[mid] ? key)</code>  中的判断符号，结合步骤 1 和给出的条件，如果是查找小于等于 <code>key</code> 的元素，则知道应该使用判断符号 <code>&gt;=</code>，因为是要返回 <code>left</code>，所以如果 <code>array[mid]</code> 等于或者大于 <code>key</code>，就应该使用 <code>&gt;=</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;二分查找问题总的来说不复杂，主要麻烦的点在于边界问题。且不同的条件下二分的写法也都不一样。接下来就做一个总结。&lt;/p&gt;
&lt;h2 id=&quot;最基础的二分查找&quot;&gt;&lt;a href=&quot;#最基础的二分查找&quot; class=&quot;headerlink&quot; title=&quot;最基础的二分查找&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://cttrevor.github.io/categories/Algorithm/"/>
    
    
      <category term="basis" scheme="https://cttrevor.github.io/tags/basis/"/>
    
  </entry>
  
  <entry>
    <title>子数组和的一系列问题（上）</title>
    <link href="https://cttrevor.github.io/2018/01/20/subarray-sum/"/>
    <id>https://cttrevor.github.io/2018/01/20/subarray-sum/</id>
    <published>2018-01-19T16:00:00.000Z</published>
    <updated>2018-01-27T08:26:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Algorithm 专题将会是我刷算法题的一些总结。对于数组类型的算法题来说，有关于子数组和的一系列问题，思路都比较类似。接下来，让我们从子数组最大累加和开始吧！</p><h2 id="子数组最大累加和"><a href="#子数组最大累加和" class="headerlink" title="子数组最大累加和"></a>子数组最大累加和</h2><h3 id="题目简析"><a href="#题目简析" class="headerlink" title="题目简析"></a>题目简析</h3><p>本题来源于<a href="https://leetcode.com/problems/maximum-subarray/" target="_blank" rel="noopener">LeetCode 53题 Maximum Subarray</a>。</p><p>给定一个数组，数组内的数字有正有零有负，求数组内累加和最大的子数组。（无论是求和的值、求子数组长度、求子数组起始点都一样，无非是记录的值不一样罢了）</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>子数组相关的问题都可以用两个 for 循环去遍历子数组的起始位置和结束位置，那么总归会遍历到那个最大累加和的子数组，从而记录并输出出来。</p><p>显而易见，这种做法的算法复杂度是<code>O(n^2)</code>。</p><p>但是这道题有一个思路很简单，但不是很容易自然想到的解法。用一个<code>current</code>值记录当前的子数组和。一旦值小于0，则置为0。同时用一个变量记录最大的<code>current</code>值。该解法虽然不容易自然想到，但很容易想到其思路的正确性：设一个数组的最大和子数组起始坐标为<code>i</code>，那么以<code>i</code>开头的子数组中若存在和小于0的，去掉这部分，显然剩下的子数组和更大。</p><p>该做法时间复杂度<code>O(n)</code>,空间复杂度<code>O(1)</code>。</p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 考虑空数组异常</span></span><br><span class="line">    <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这样写可以避免数组内都是负数的情况，max会保存最大的负数</span></span><br><span class="line">    <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        cur += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(max &lt; cur) max = cur;</span><br><span class="line">        <span class="keyword">if</span>(cur &lt; <span class="number">0</span>) cur = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="累加和为给定值-k-的子数组"><a href="#累加和为给定值-k-的子数组" class="headerlink" title="累加和为给定值 k 的子数组"></a>累加和为给定值 k 的子数组</h2><h3 id="题目简析-1"><a href="#题目简析-1" class="headerlink" title="题目简析"></a>题目简析</h3><p>这类型有三种题，一个是来源于<a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode 560题 Subarray Sum Equals K</a>。该题为求累加和为给定值的子数组的数量。另一种为求子数组的最大长度。</p><p>第三种相对较简单，在第二种题的基础上增加限定条件：所给数组元素均为非负数（或都是正数）。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>子数组和相关的问题如果想通过一次遍历就能得到结果，思路都可以往累加和的差上去考虑。比如<code>a[i]</code> 到 <code>a[j]</code> 的累加和，等于 <code>a[0]</code> 到 <code>a[j]</code> 的累加和减去 <code>a[0]</code> 到 <code>a[i-1]</code> 的累加和。因此，若把累加和记做一个数组，也许就能想到用空间换取时间的算法。</p><p>前两种题做法相差不大。都是利用哈希表对已计算的累加和进行存储。首先我们可以很容易想到的是，当得到当前 <code>i</code> 位置的累加和 <code>sum</code> 时，若 <code>sum - k</code> 在累加和数组之前存在，那么就存在以 <code>i</code> 结尾的累加和为 <code>k</code> 的数组。而哈希表可以把遍历累加和数组的过程变成 <code>O(1)</code> 的时间复杂度。</p><p>对于统计子数组数量来说，哈希表存放的是当前累加和出现过的次数。而对于求最长子数组来说，哈希表存放的是当前累加和最早出现的位置。</p><p>哈希表的解法时间复杂度 <code>O(n)</code>，空间复杂度 <code>O(n)</code>。</p><p>对于第三题来说，由于有了非负数（或正数）的限定条件，left、right 两指针的思路很清晰：当前和小于等于 <code>k</code>，右指针向右移动，同时加上右指针的值；若大于，则左指针向右，同时减去左指针的值。同时，记录等于 <code>k</code> 时的最长长度。该解法时间复杂度 <code>O(n)</code>，空间复杂度 <code>O(1)</code>。</p><h3 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h3><p>前两题：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 始终记得处理空数组</span></span><br><span class="line">    <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; sumMap;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于初始时数组和为0的处理（很重要！）：</span></span><br><span class="line">    <span class="comment">// 第一题，先记录0出现了1次</span></span><br><span class="line">    sumMap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 第二题，先记录0出现在-1的位置上</span></span><br><span class="line">    <span class="comment">// sumMap[0] = -1;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;     <span class="comment">// 当前数组和</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(sumMap.find(sum - k) != sumMap.end())  <span class="comment">// 若 sum - k 已存在</span></span><br><span class="line">            count += sumMap[sum - k];</span><br><span class="line">            <span class="comment">// count = max(count, i - sumMap[sum - k])</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 在哈希表中记录sum</span></span><br><span class="line">        <span class="keyword">if</span>(sumMap.find(sum) == sumMap.end())</span><br><span class="line">            sumMap[sum] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// sumMap[sum] = i;</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sumMap[sum]++;</span><br><span class="line">            <span class="comment">// 对于第二题，若 sum 已经出现过，不做任何处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三题：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size() == <span class="number">0</span> || k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; nums.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == k) &#123;</span><br><span class="line">            res = max(res, right - left);</span><br><span class="line">            sum += nums[right++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; k) &#123;</span><br><span class="line">            sum += nums[right++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; k) &#123;</span><br><span class="line">            sum -= nums[left--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充题目"><a href="#补充题目" class="headerlink" title="补充题目"></a>补充题目</h3><p>1、给定一个数组，求所有子数组中正数与负数个数相等的最长子数组长度。</p><p>2、给定一个数组，其中元素只有 1 或 0。求所有子数组中 1 与 0 个数相等的最长子数组长度。</p><p>理解了前面的原题解法后，这两道补充题思路很简单，第一题把所有正数变成 1，所有负数变成 -1，即所求为新数组中和为 0 的最长子数组。第二题几位 1 不变，0 变成 -1 后的新数组中和为 0 的最长子数组。</p><h2 id="累加小于等于给定值-k-的子数组"><a href="#累加小于等于给定值-k-的子数组" class="headerlink" title="累加小于等于给定值 k 的子数组"></a>累加小于等于给定值 k 的子数组</h2><h3 id="题目简析-2"><a href="#题目简析-2" class="headerlink" title="题目简析"></a>题目简析</h3><p>给定一个数组，数组内的数字有正有零有负，求数组内累加小于等于 k 的最长子数组长度。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>该题看起来跟累加和等于 k 的题目差不多，但实际上比上一题要难不少。主要难点在于哈希表无法存储大于或等于某一个值的累加和最早出现的位置。为了在小于 <code>O(n)</code> 的时间复杂度内找到该位置，我们采用一个辅助数组来存储最大的累加和。这样一来，得到的辅助数组是有序的，故可以通过二分查找找到大于或等于某一个值的累加和最早出现的位置。思路还是比较清晰的，所以还是看代码为主吧。</p><p>该做法时间复杂度<code>O(nlogn)</code>,空间复杂度<code>O(1)</code>。</p><h3 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxLenth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSum;</span><br><span class="line">    <span class="keyword">int</span> sum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> pre = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    maxSum.push_back(pre);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        pre = max(pre, sum);</span><br><span class="line">        maxSum.push_back(pre);</span><br><span class="line">        <span class="keyword">int</span> index = getIndex(maxSum, sum - k)</span><br><span class="line">        res = max((index == <span class="number">-1</span>) ? <span class="number">0</span> : (i - index + <span class="number">1</span>), res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= k) &#123;</span><br><span class="line">            res = mid;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Algorithm 专题将会是我刷算法题的一些总结。对于数组类型的算法题来说，有关于子数组和的一系列问题，思路都比较类似。接下来，让我们从子数组最大累加和开始吧！&lt;/p&gt;
&lt;h2 id=&quot;子数组最大累加和&quot;&gt;&lt;a href=&quot;#子数组最大累加和&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://cttrevor.github.io/categories/Algorithm/"/>
    
    
      <category term="Array" scheme="https://cttrevor.github.io/tags/Array/"/>
    
      <category term="LeetCode" scheme="https://cttrevor.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://cttrevor.github.io/2018/01/08/hello-world/"/>
    <id>https://cttrevor.github.io/2018/01/08/hello-world/</id>
    <published>2018-01-07T16:00:00.000Z</published>
    <updated>2018-01-27T08:25:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实一直都有想做一个博客的想法，一方面为了记录我的技术成长，另一方面来说，如果能有更多的人关注的话，也可以交流一下，共同成长。Hexo 是一个关注了很久的一个快速简洁的博客框架。作为第一篇博客，还是按照很多 Hexo 博主的惯例，写一写 Hexo 的 Hello World。</p><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Node.js 的安装网上有很多的教程，对于一个前端程序员来说，Node 也是一个经常会接触到的东西，这里就暂且不表。我们的安装过程从安装 Hexo 开始。</p><p>打开终端，用<code>npm install</code>安装 Hexo ：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="在本地创建一个博客站"><a href="#在本地创建一个博客站" class="headerlink" title="在本地创建一个博客站"></a>在本地创建一个博客站</h3><p>在准备创建文件夹的位置打开终端：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>至此，Hexo博客在本地安装完毕，浏览器输入<code>http://localhost:4000</code>，即可在本地运行。若无法运行，可能是<code>4000</code>端口被占用，可用 <code>hexo s -p 4001</code> 指定端口号，其中 <code>4001</code> 自定。也可修改 <code>node_modules\hexo-server\index.js</code> 中默认的 <code>port</code> 值解决。</p><h3 id="在Github上托管博客"><a href="#在Github上托管博客" class="headerlink" title="在Github上托管博客"></a>在Github上托管博客</h3><p>在 Github 上建立与你用户名对应的仓库，仓库名必须为 <code>username.github.io</code></p><p>配置 Hexo 文件夹的 <code>_config.yml</code> 文件，翻到最下面，改成：</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">    repository:</span> <span class="attr">https://github.com/abc/abc.github.io.git</span></span><br><span class="line"><span class="attr">    branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><p>注意 <code>yml</code> 配置文件冒号后面有空格。</p><p>然后在终端上输入以下指令部署到 <code>Github</code> 上：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><p>若出现报错：<code>ERROR Deployer not found：git</code> 在终端上运行：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure><h3 id="生成新的文章"><a href="#生成新的文章" class="headerlink" title="生成新的文章"></a>生成新的文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_post</code></td></tr><tr><td><code>page</code></td><td><code>source</code></td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table><h3 id="更改博客主题"><a href="#更改博客主题" class="headerlink" title="更改博客主题"></a>更改博客主题</h3><p>博客主题保存在 <code>themes</code> 文件夹下，初始创建时 Hexo 为我们创建了一个默认的主题 <code>landscape</code> 。</p><p>博客主题可以在 Github 和 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes</a> 上搜寻。本站主题地址<a href="https://github.com/haojen/hexo-theme-Anisina" target="_blank" rel="noopener">点击此处</a>。</p><p>修改 <code>_config.yml</code> 中的 <code>theme</code> 来指定博客主题。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在 <code>_config.yml</code> 包括对应主题的文件夹下的 <code>_config.yml</code> 中还有很多的配置项，具体配置说明参照<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="noopener">Hexo官方配置文档</a>以及主题 Github 的说明。</p><p>其他文档参照<a href="https://hexo.io/zh-cn/api/index.html" target="_blank" rel="noopener">Hexo官方API</a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;其实一直都有想做一个博客的想法，一方面为了记录我的技术成长，另一方面来说，如果能有更多的人关注的话，也可以交流一下，共同成长。Hexo 是一个关注了很久的一个快速简洁的博客框架。作为第一篇博客，还是按照很多 Hexo 博主的惯例，写一写 Hexo 的 Hello World
      
    
    </summary>
    
      <category term="Others" scheme="https://cttrevor.github.io/categories/Others/"/>
    
    
      <category term="Hexo" scheme="https://cttrevor.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
